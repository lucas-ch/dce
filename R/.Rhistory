rows <- d[d$set == s, ]
if (nrow(rows) != 2) {
warning(sprintf("Le set %s ne contient pas exactement 2 alternatives (en contient %d). Ignoré.", s, nrow(rows)))
next
}
# s'assurer alt1 -> colonne A, alt2 -> colonne B (si elles existent)
alt1_row <- rows[rows$alt == 1, , drop = FALSE]
alt2_row <- rows[rows$alt == 2, , drop = FALSE]
# si l'ordre n'est pas 1/2, on ordonne simplement par alt
rows <- rows[order(rows$alt), ]
alt1 <- rows[1, ]
alt2 <- rows[2, ]
# construire data.frame 5 x 2 (ligne = attribut)
card_df <- data.frame(
Option_A = as.character(alt1[ paste0("V", seq_along(labels)) ]),
Option_B = as.character(alt2[ paste0("V", seq_along(labels)) ]),
stringsAsFactors = FALSE
)
rownames(card_df) <- labels
cards_list[[s]] <- card_df
}
library(gridExtra)
library(grid)
library(stringr)
save_simple_table <- function(card_df, outfile = "table.png",
width = 1300, height = 700, dpi = 150,
wrap_width = 30,
fixed_cols = c("Option_A", "Option_B"),
fixed_width = 8) {
# convertir et enrouler les textes
card_df <- as.data.frame(card_df, stringsAsFactors = FALSE)
card_df[] <- lapply(card_df, function(x) str_wrap(as.character(x), width = wrap_width))
# calculer largeur par colonne (unit objects)
col_names <- colnames(card_df)
ncol_df <- ncol(card_df)
widths_list <- vector("list", length = ncol_df)
for (i in seq_len(ncol_df)) {
col_vec <- as.character(card_df[[i]])
# mesurer largeur maximale du contenu + en-tête
max_content_width <- max(stringWidth(textGrob(c(col_names[i], col_vec))))
padding <- unit(5, "mm")  # petit padding pour respirer
if (col_names[i] %in% fixed_cols) {
# colonne à largeur fixe
widths_list[[i]] <- unit(fixed_width, "cm")
} else {
# largeur calculée d'après le contenu + padding
widths_list[[i]] <- max_content_width + padding
}
}
# convertir la liste en vecteur unit utilisable par tableGrob
widths_units <- do.call(unit.c, widths_list)
# créer table simple en forçant les largeurs
tg <- tableGrob(card_df, widths = widths_units)
# enregistrer
png(filename = outfile, width = width, height = height, units = "px", res = dpi)
grid.newpage()
grid.draw(tg)
dev.off()
}
dir.create("cards_simple", showWarnings = FALSE)
for (s in names(cards_list)) {
save_simple_table(cards_list[[s]],
outfile = file.path("cards_simple", paste0(s, ".png")))
}
al <- list(
c("0 jour","2 jours/semaine", "5 jours"),
c("Horaires stricts. 9h - 17h","Horaires flexibles. 7h/jour sans autre contrainte"),
c("Équipement de base : bureau, fauteuil simple, un seul écran, ordinateur bas de gamme.","Équipement ergonomique complet : bureau réglable, fauteuil ergonomique, double écran et ordinateur haut de gamme."),
c("11mn","27mn", "45mn"),
c("1934e","2028e", "2146e")
)
a = Decode(des=design,n.alts = 2, lvl.names = al,
coding=coding)
d <- as.data.frame(a$design, stringsAsFactors = FALSE)
if (is.null(rownames(d))) stop("Le data.frame 'design' doit avoir des rownames du type 'setX.altY'.")
# 2) mapping des colonnes vers des libellés lisibles (modifier si besoin)
labels <- c("Jours de télétravail", "Flexibilité horaire", "Equipement à domicile", "Temps de trajet", "Salaire")
if (ncol(d) < length(labels)) stop("Le design a moins de colonnes que de labels.")
# garder seulement le nombre de labels correspondant aux colonnes
labels <- labels[seq_len(ncol(d))]
# 3) extraire info set / alt
rn <- rownames(d)
set_ids <- sub("\\.alt.*$", "", rn)                # ex "set1"
alt_nums <- as.integer(gsub("^.*\\.alt", "", rn)) # 1 ou 2
d$set <- set_ids
d$alt <- alt_nums
# 4) lister sets dans l'ordre (set1, set2, ...)
sets <- sort(unique(d$set))
# 5) construire une liste de data.frames (une carte par set)
cards_list <- list()
for (s in sets) {
rows <- d[d$set == s, ]
if (nrow(rows) != 2) {
warning(sprintf("Le set %s ne contient pas exactement 2 alternatives (en contient %d). Ignoré.", s, nrow(rows)))
next
}
# s'assurer alt1 -> colonne A, alt2 -> colonne B (si elles existent)
alt1_row <- rows[rows$alt == 1, , drop = FALSE]
alt2_row <- rows[rows$alt == 2, , drop = FALSE]
# si l'ordre n'est pas 1/2, on ordonne simplement par alt
rows <- rows[order(rows$alt), ]
alt1 <- rows[1, ]
alt2 <- rows[2, ]
# construire data.frame 5 x 2 (ligne = attribut)
card_df <- data.frame(
Option_A = as.character(alt1[ paste0("V", seq_along(labels)) ]),
Option_B = as.character(alt2[ paste0("V", seq_along(labels)) ]),
stringsAsFactors = FALSE
)
rownames(card_df) <- labels
cards_list[[s]] <- card_df
}
library(gridExtra)
library(grid)
library(stringr)
save_simple_table <- function(card_df, outfile = "table.png",
width = 1300, height = 700, dpi = 150,
wrap_width = 30,
fixed_cols = c("Option_A", "Option_B"),
fixed_width = 8) {
# convertir et enrouler les textes
card_df <- as.data.frame(card_df, stringsAsFactors = FALSE)
card_df[] <- lapply(card_df, function(x) str_wrap(as.character(x), width = wrap_width))
# calculer largeur par colonne (unit objects)
col_names <- colnames(card_df)
ncol_df <- ncol(card_df)
widths_list <- vector("list", length = ncol_df)
for (i in seq_len(ncol_df)) {
col_vec <- as.character(card_df[[i]])
# mesurer largeur maximale du contenu + en-tête
max_content_width <- max(stringWidth(textGrob(c(col_names[i], col_vec))))
padding <- unit(5, "mm")  # petit padding pour respirer
if (col_names[i] %in% fixed_cols) {
# colonne à largeur fixe
widths_list[[i]] <- unit(fixed_width, "cm")
} else {
# largeur calculée d'après le contenu + padding
widths_list[[i]] <- max_content_width + padding
}
}
# convertir la liste en vecteur unit utilisable par tableGrob
widths_units <- do.call(unit.c, widths_list)
# créer table simple en forçant les largeurs
tg <- tableGrob(card_df, widths = widths_units)
# enregistrer
png(filename = outfile, width = width, height = height, units = "px", res = dpi)
grid.newpage()
grid.draw(tg)
dev.off()
}
dir.create("cards_simple", showWarnings = FALSE)
for (s in names(cards_list)) {
save_simple_table(cards_list[[s]],
outfile = file.path("cards_simple", paste0(s, ".png")))
}
source("~/dce/R/design_dce.R")
source("~/dce/R/analyse_dce.R")
source("~/dce/R/analyse_dce.R")
source("~/dce/R/analyse_dce.R")
View(data_full)
getwd()
# Charger les données à analyser et le plan du DCE
data <- read_csv("../data/all_apps_wide.csv")
design_dce <- readRDS("design_dce.rds")
# Formatter les données pour une analyse logit
data_long <- data %>%
select(participant.id_in_session,
matches("^dce\\.\\d+\\.player\\.(alt|set|block|selected)")) %>%
pivot_longer(
cols = -participant.id_in_session,
names_to = c("round", ".value"),
names_pattern = "dce\\.(\\d+)\\.player\\.(.*)"
) %>%
mutate(round = as.integer(round)) %>%
rename(id = participant.id_in_session)
data_full <- data_long %>%
select(id, round, set, selected) %>%
distinct()%>%
left_join(design_dce, by = "set") %>%
select(id, round, set, alt,selected, tt, flex, ergo, distance, salaire) %>%
mutate(choice_bin = ifelse(alt == selected, 1, 0))
# Ajouter les infos démographiques
participant_info <- data %>%
select(id = participant.id_in_session,
age = dce.1.player.age,
genre = dce.1.player.genre,
etudes = dce.1.player.etudes,
filiere = dce.1.player.filiere)
data_full <- data_full %>%
left_join(participant_info, by = "id")
# Analyse logit multinomial
clogout1 <- clogit(choice_bin ~ tt + salaire + distance,
data = data_full)
clogout1
# Analyse logit multinomial
clogout <- clogit(choice_bin ~ tt + salaire + distance + ergo +
tt:distance +
tt:ergo +
strata(id, round),
data = data_full)
clogout
# Analyse logit multinomial
clogout <- clogit(choice_bin ~ tt + salaire + distance + ergo +
strata(id, round),
data = data_full)
clogout
data_full
library(tidyverse)
library(patchwork) # Pour combiner les graphiques
library(corrplot)  # Pour la matrice de corrélation
install.packages(corrplot)
install.packages("corrplot")
install.packages("patchwork")
library(tidyverse)
library(patchwork) # Pour combiner les graphiques
library(corrplot)  # Pour la matrice de corrélation
# --- 1. Préparation des données ---
# S'assurer que les variables catégorielles sont des facteurs
df_plot <- data_full %>%
mutate(
filiere = factor(filiere, labels = c("Filière 0", "Filière 1", "Filière 2")),
etudes = factor(etudes),
genre = factor(genre, labels = c("Femme", "Homme")),
tt_fact = factor(tt)
)
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal() + show_guide = FALSE
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal() + show_guide = FALSE
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal() + show_guide = FALSE
# Graphique pour le niveau d'études (80% au niveau 5)
p2 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = etudes, fill = etudes)) +
geom_bar() +
labs(title = "Répartition par Niveau d'Études", y = "Nombre de répondants") +
theme_minimal()
# --- 3. Analyse des Choix (Préférences Brutes) ---
# Taux de choix selon le Télétravail
p3 <- df_plot %>%
group_by(tt) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = factor(tt), y = prob, group = 1)) +
geom_line(color = "steelblue", size = 1) +
geom_point(size = 3, color = "steelblue") +
scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
labs(title = "Effet brut du Télétravail", x = "Jours de TT", y = "% de Choix") +
theme_minimal()
# Taux de choix selon le Salaire (on crée des bins pour la lisibilité)
p4 <- df_plot %>%
mutate(salaire_grp = cut(salaire, breaks = 5)) %>%
group_by(salaire_grp) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = salaire_grp, y = prob)) +
geom_col(fill = "#00BFC4") +
scale_y_continuous(labels = scales::percent) +
labs(title = "Effet brut du Salaire", x = "Tranches de Salaire", y = "% de Choix") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal() + show_guide = FALSE
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 = ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal() + show_guide = FALSE
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 = ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal() + show_guide = FALSE
# Graphique pour la filière (80% / 10% / 10%)
p1 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal()
# --- 4. Analyse des Interactions (Visualisation) ---
# Interaction Télétravail x Distance
p5 <- df_plot %>%
mutate(dist_cat = ifelse(distance > median(distance), "Loin", "Proche")) %>%
group_by(tt, dist_cat) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = tt, y = prob, color = dist_cat)) +
geom_line(size = 1) +
geom_point(size = 2) +
scale_y_continuous(labels = scales::percent) +
labs(title = "Interaction : TT et Distance", x = "Jours de TT", y = "% de Choix", color = "Distance") +
theme_minimal()
# --- 5. Matrice de Corrélation (Validation du Design) ---
# On vérifie que les attributs ne sont pas corrélés (Design expérimental)
cor_matrix <- cor(design_dce[, c("tt", "salaire", "distance", "ergo", "flex")])
# --- 6. Affichage Combiné ---
(p1 | p2) / (p3 | p4) / p5
cor_matrix
df_plot
# Taux de choix selon le Salaire (on crée des bins pour la lisibilité)
p4 <- df_plot %>%
group_by(salaire_grp) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = salaire_grp, y = prob)) +
geom_col(fill = "#00BFC4") +
scale_y_continuous(labels = scales::percent) +
labs(title = "Effet brut du Salaire", x = "Tranches de Salaire", y = "% de Choix") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Taux de choix selon le Salaire (on crée des bins pour la lisibilité)
p4 <- df_plot %>%
group_by(salaire) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = salaire, y = prob)) +
geom_col(fill = "#00BFC4") +
scale_y_continuous(labels = scales::percent) +
labs(title = "Effet brut du Salaire", x = "Tranches de Salaire", y = "% de Choix") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# --- 6. Affichage Combiné ---
(p1 | p2) / (p3 | p4) / p5
source("~/dce/R/data_dce.R")
source("~/dce/R/logit_dce.R")
clogout
source("~/dce/R/logit_dce.R")
# --- 1. Préparation des données ---
# S'assurer que les variables catégorielles sont des facteurs
df_plot <- df %>%
mutate(
filiere = factor(filiere, labels = c("Economie", "Management", "AES")),
etudes = factor(etudes, lables = c("Licence 3", "Master 1", "Master 2")),
genre = factor(genre, labels = c("Femme", "Homme")),
tt_fact = factor(tt)
)
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal()
# --- 1. Préparation des données ---
# S'assurer que les variables catégorielles sont des facteurs
df_plot <- df %>%
mutate(
filiere = factor(filiere, labels = c("Economie", "Management", "AES")),
etudes = factor(etudes, lables = c("Licence 3", "Master 1", "Master 2")),
genre = factor(genre, labels = c("Femme", "Homme")),
tt_fact = factor(tt)
)
# --- 1. Préparation des données ---
# S'assurer que les variables catégorielles sont des facteurs
df_plot <- df %>%
mutate(
filiere = factor(filiere, labels = c("Economie", "Management", "AES")),
etudes = factor(etudes, labels = c("Licence 3", "Master 1", "Master 2")),
genre = factor(genre, labels = c("Femme", "Homme")),
tt_fact = factor(tt)
)
# --- 2. Analyses Démographiques (Validation de votre simulation) ---
# Graphique pour la filière (80% / 10% / 10%)
p1 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = filiere, fill = filiere)) +
geom_bar() +
labs(title = "Répartition par Filière", y = "Nombre de répondants") +
theme_minimal()
p1
# Graphique pour le niveau d'études (80% au niveau 5)
p2 <- ggplot(df_plot %>% distinct(id, .keep_all = TRUE), aes(x = etudes, fill = etudes)) +
geom_bar() +
labs(title = "Répartition par Niveau d'Études", y = "Nombre de répondants") +
theme_minimal()
p2
# --- 3. Analyse des Choix (Préférences Brutes) ---
# Taux de choix selon le Télétravail
p3 <- df_plot %>%
group_by(tt) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = factor(tt), y = prob, group = 1)) +
geom_line(color = "steelblue", size = 1) +
geom_point(size = 3, color = "steelblue") +
scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
labs(title = "Effet brut du Télétravail", x = "Jours de TT", y = "% de Choix") +
theme_minimal()
# Taux de choix selon le Salaire (on crée des bins pour la lisibilité)
p4 <- df_plot %>%
group_by(salaire) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = salaire, y = prob)) +
geom_col(fill = "#00BFC4") +
scale_y_continuous(labels = scales::percent) +
labs(title = "Effet brut du Salaire", x = "Tranches de Salaire", y = "% de Choix") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# --- 4. Analyse des Interactions (Visualisation) ---
# Interaction Télétravail x Distance
p5 <- df_plot %>%
mutate(dist_cat = ifelse(distance > median(distance), "Loin", "Proche")) %>%
group_by(tt, dist_cat) %>%
summarise(prob = mean(choice_bin)) %>%
ggplot(aes(x = tt, y = prob, color = dist_cat)) +
geom_line(size = 1) +
geom_point(size = 2) +
scale_y_continuous(labels = scales::percent) +
labs(title = "Interaction : TT et Distance", x = "Jours de TT", y = "% de Choix", color = "Distance") +
theme_minimal()
# --- 5. Matrice de Corrélation (Validation du Design) ---
# On vérifie que les attributs ne sont pas corrélés (Design expérimental)
cor_matrix <- cor(design_dce[, c("tt", "salaire", "distance", "ergo", "flex")])
design_dce <- readRDS("design_dce.rds")
# --- 5. Matrice de Corrélation (Validation du Design) ---
# On vérifie que les attributs ne sont pas corrélés (Design expérimental)
cor_matrix <- cor(design_dce[, c("tt", "salaire", "distance", "ergo", "flex")])
View(cor_matrix)
install.packages("viridis")
# 1. Calculer le pourcentage de choix par combinaison Salaire/TT
heatmap_data <- df %>%
group_by(salaire, tt) %>%
summarise(
total_presente = n(),                      # Nombre de fois que ce duo est apparu
total_choisi = sum(choice_bin),            # Nombre de fois qu'il a été choisi
pct_choisi = total_choisi / total_presente, # Taux de succès
.groups = 'drop'
)
# 2. Créer le graphique
ggplot(heatmap_data, aes(x = factor(tt), y = factor(salaire), fill = pct_choisi)) +
geom_tile(color = "white", size = 0.5) + # Crée les carrés
geom_text(aes(label = scales::percent(pct_choisi, accuracy = 1)),
color = "white", fontface = "bold") + # Ajoute le texte du %
scale_fill_viridis(option = "D", labels = scales::percent) +
labs(
title = "Attractivité des combinaisons Salaire x Télétravail",
subtitle = "Pourcentage de choix moyen pour chaque combinaison d'attributs",
x = "Jours de Télétravail (tt)",
y = "Salaire",
fill = "Taux de choix"
) +
theme_minimal()
library(viridis) # Pour une échelle de couleurs lisible
# 2. Créer le graphique
ggplot(heatmap_data, aes(x = factor(tt), y = factor(salaire), fill = pct_choisi)) +
geom_tile(color = "white", size = 0.5) + # Crée les carrés
geom_text(aes(label = scales::percent(pct_choisi, accuracy = 1)),
color = "white", fontface = "bold") + # Ajoute le texte du %
scale_fill_viridis(option = "D", labels = scales::percent) +
labs(
title = "Attractivité des combinaisons Salaire x Télétravail",
subtitle = "Pourcentage de choix moyen pour chaque combinaison d'attributs",
x = "Jours de Télétravail (tt)",
y = "Salaire",
fill = "Taux de choix"
) +
theme_minimal()
# 1. Calculer le taux de choix de l'Alternative 1 par set
check_dominant <- df %>%
filter(alt == 1) %>% # On ne garde qu'une ligne par set pour calculer le taux
group_by(set) %>%
summarise(
pct_alt1 = mean(choice_bin),
total = n()
) %>%
mutate(is_obvious = pct_alt1 > 0.9 | pct_alt1 < 0.1) # Marquer les questions extrêmes
# 2. Plot
ggplot(check_dominant, aes(x = factor(set), y = pct_alt1, fill = is_obvious)) +
geom_col() +
geom_hline(yintercept = 0.5, linetype = "dashed", color = "red", alpha = 0.5) +
scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
scale_fill_manual(values = c("steelblue", "#FF6666"),
labels = c("Équilibrée", "Potentiellement évidente")) +
labs(
title = "Détection des questions 'Évidentes'",
subtitle = "Pourcentage de choix pour l'Alternative 1 par Set",
x = "Numéro du Set (Question)",
y = "% Choix Alternative 1",
fill = "Statut"
) +
theme_minimal()
# 1. Calculer le taux de choix de l'Alternative 1 par set
check_dominant <- df %>%
filter(alt == 1) %>% # On ne garde qu'une ligne par set pour calculer le taux
group_by(set) %>%
summarise(
pct_alt1 = mean(choice_bin),
total = n()
) %>%
mutate(is_obvious = pct_alt1 > 0.85 | pct_alt1 < 0.15) # Marquer les questions extrêmes
# 2. Plot
ggplot(check_dominant, aes(x = factor(set), y = pct_alt1, fill = is_obvious)) +
geom_col() +
geom_hline(yintercept = 0.5, linetype = "dashed", color = "red", alpha = 0.5) +
scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
scale_fill_manual(values = c("steelblue", "#FF6666"),
labels = c("Équilibrée", "Potentiellement évidente")) +
labs(
title = "Détection des questions 'Évidentes'",
subtitle = "Pourcentage de choix pour l'Alternative 1 par Set",
x = "Numéro du Set (Question)",
y = "% Choix Alternative 1",
fill = "Statut"
) +
theme_minimal()
